---
date: 2020-1-11
tag: 
  - JVM
author: NeroBlackstone
location: NanChang
summary: ZGC好在哪里呢？
---

# JVM ZGC 简介

如今服务端面向百万级的客户端服务的场景已经越来越常见。这样的程序需要大量的内存，传统方法管理这些内存也会导致一些性能问题。

Java 11 引入的实验性GC实现：ZGC，便是为了解决这个问题。

本文介绍ZGC如何在高达TB级的堆中以极低的暂停时间回收内存。

## 基本概念

为了理解ZGC如何工作，首先需要了解一些内存管理和GC有关的基础概念和理论。

### 内存管理

物理内存，是电脑硬件提供的内存。虚拟内存，是操作系统堆为每个应用分配的内存。我们将**虚拟内存存储到物理内存中，并且OS实时地维护两者的映射**。

### 多重映射（Multi-mapping）

多重映射意味着虚拟内存中有指向物理内存的特殊地址。由于程序通过虚拟内存访问数据，程序不知道也不需要知道这里的底层机制。

**实际上，os会把相同区域的物理内存分配到多块物理内存当中。**

![jvm-multi-mapping](./img/jvm-multi-mapping.png)

看上去这样做并没有什么好处，但是这是ZGC实现的基础，并且由于这种机制分离了应用程序的间的内存空间，保障了安全性。

### 再分配

由于使用动态内存分配，普通程序的内存会随着运行时间推移变得碎片化。这是因为在内存中清除对象时，会留下那段内存被释放后的内存间隙。随着时间流逝，间隙不断积累，内存会变得像是由可用空间和已用空间交织的棋盘格。

当然我们可以尝试使用新对象去填补这些空白。要做到这一点，可以扫描内存，去找到足够容纳新对象的可用空间。如果每次分配内存都要执行这种操作，将会非常耗时。此外，由于有可能不能找到刚好大小合适的内存空间，内存仍将是零碎的，对象间将存在非常小的间隙。也可以尝试最小化这些间隙，但也需要更多的处理资源。

另外一种策略是更频繁地**从碎片化的内存中，移动对象到一块新的可用区域，使分区更加紧凑**。为了追求效率，可以把内存分割为一个个小区块，移动对象以填满区块，或保持区块为空。这样下来，由于知道这些一整块为空的区块的存在，内存分配将会更加快速。

### GC

上面讲的是JVM出现前的情况（回顾大学里操作系统课的内容）。当创建java程序时，我们其实不用释放我们分配出去的内存，因为垃圾收集器会帮我们全部搞定。**GC通过引用链监视着程序中无法到达的对象，并且释放这些对象占用的内存**。

GC需要跟踪堆空间中对象的状态来完成工作。举个例子，**可达状态**意味着程序保有这个对象的引用，当然这个引用也是可传递的，只要程序可以访问这些引用找到对象即可。另一个状态是**可终结状态**：无法访问的对象即为可终结的，这些对象就是我们要去回收的垃圾。

![jvm-multi-mapping](./img/jvm-object-state.png)

GC会走多个步骤去获取堆空间的对象可达性信息。

### GC阶段

GC阶段有着不同的属性

- parallel阶段可以运行多个GC线程
- serail阶段运行在单个线程上
- stop-the-world阶段不能与应用代码一同运行
- concurrent阶段可以在后台工作，程序可照常运行
- increment阶段可以在结束前暂停所有的工作，并且稍后重启

上述所有技术都有其优缺点。举个例子，假设有一个可以和我们的程序代码并发运行的阶段。使用serial实现只需要1%的cpu占用，但是需要运行1000毫秒。而相反，使用parallel实现需要占用30%的cpu并且仅仅50ms完成工作。

看起使用parallel实现非常快，但是**parallel的解决方案使用了更多cpu，因为它更加复杂并且必须同步线程**。对于cpu占用高的应用（像批处理）就不太适合，因为用于真正有意义的工作的cpu变少了。

虽然这只是举个例子，但是很明显所有程序都有它自己的特征，不同的程序会有不同的GC要求。（软件工程没有银弹）

## ZGC概念

